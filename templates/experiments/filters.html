<div x-data="filterComponent" @click.outside="filterData.showFilters = false" class="relative">
  <!-- Filter Button -->
  <div class="flex items-center">
    <button type="button" @click="toggleFilters()" class="btn btn-sm btn-outline">
      <i class="fa-solid fa-filter"></i> Filter
      <span x-show="getActiveFilterCount() > 0" x-cloak>(<span x-text="getActiveFilterCount()"></span>)</span>
    </button>

    <div x-show="filterData.loading" x-cloak class="btn btn-square btn-sm btn-ghost animate-none cursor-auto">
      <i class="fa-solid fa-spinner fa-spin"></i>
    </div>

    <!-- Clear filters button -->
    <button
      type="button"
      x-show="getActiveFilterCount() > 0 && !filterData.loading"
      @click="clearAllFilters()"
      class="btn btn-square btn-sm btn-ghost"
      title="Clear all filters" x-cloak>
      x
    </button>
    <!-- Date Range dropdown filter -->
    <div class="dropdown">
      <div tabindex="0" role="button" class="btn btn-ghost btn-sm normal-case">
        <i class="fa-regular fa-clock"></i>
        <span x-text="selectedLabel || 'Date Range'" class="dropdown-label"></span>
        <i class="fa-solid fa-caret-down ml-1"></i>
      </div>
      <ul tabindex="0" class="dropdown-content menu p-2 shadow bg-base-100 rounded-box w-52">
        <template x-for="option in dateRangeOptions" :key="option.value">
          <li>
            <a href="#" x-text="option.label" @click.prevent="selectOption(option); document.activeElement.blur()"></a>
          </li>
        </template>
      </ul>
    </div>
  </div>

  <!-- Filters Panel -->
  <div x-show="filterData.showFilters" class="absolute left-0 mt-2 p-4 bg-base-100 border border-base-200 rounded-lg shadow-lg z-10 min-w-max max-w-screen-lg" x-cloak>
    <div class="space-y-2">
      <template x-for="(filter, index) in filterData.filters" :key="index">
        <div class="flex items-center gap-2">
          <!-- Where/AND Label -->
          <div class="text-gray-500 font-medium w-16">
            <span x-text="index === 0 ? 'Where' : 'AND'"></span>
          </div>

          <!-- Column Selector -->
          <div class="relative">
            <div class="dropdown dropdown-bottom">
              <label tabindex="0" class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center" style="height: 2rem;">
                <span x-text="filter.column ? filterData.columns[filter.column].label : 'Select column'"></span>
                <i class="fa-solid fa-caret-down fa-sm"></i>
              </label>
              <ul tabindex="0" class="dropdown-content z-1 menu mt-1 p-2 bg-base-100 rounded-lg border border-base-200 w-40">
                <template x-for="(config, column) in filterData.columns" :key="column">
                  <li><a @click="filter.column = column; updateOperatorsByColumn(index)" x-text="config.label"></a></li>
                </template>
              </ul>
            </div>
          </div>

          <!-- Operator Selector -->
          <div x-show="filter.column" class="relative">
            <div class="dropdown dropdown-bottom">
              <label tabindex="0" class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center" style="height: 2rem;">
                <span x-text="filter.operator || 'Select operator'"></span>
                <i class="fa-solid fa-caret-down fa-sm"></i>
              </label>
              <ul tabindex="0" class="dropdown-content z-1 menu mt-1 p-2 bg-base-100 rounded-lg border border-base-200 w-40">
                <template x-for="operator in filter.availableOperators" :key="operator">
                  <li><a @click="filter.operator = operator; triggerFilterChange()" x-text="operator"></a></li>
                </template>
              </ul>
            </div>
          </div>

          <!-- Value Input (Choice, String, Timestamp) -->
          <template x-if="filter.operator">
            <div class="relative">
              <template x-if="['choice', 'string', 'exclusive_choice'].includes(filterData.columns[filter.column]?.type) && ['any of', 'all of', 'excludes'].includes(filter.operator)">
                <div class="relative">
                  <div @click="filter.showOptions = !filter.showOptions" class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center" style="height: 2rem;">
                    <span x-text="filter.selectedValues.length ? getSelectedDisplayText(filter) : 'Select'"></span>
                    <i class="fa-solid fa-caret-down fa-sm"></i>
                  </div>
                  <div x-show="filter.showOptions" @click.outside="filter.showOptions = false" class="absolute z-50 mt-1 bg-base-100 rounded-lg max-h-64 overflow-y-auto w-48 border border-base-300" style="z-index: 9999 !important;">
                    <div class="sticky top-0 bg-base-100 border-b p-2 z-1">
                      <div class="relative">
                        <input type="text" x-model="filter.searchQuery" @input="filterDropdownOptions(index)" placeholder="Search..." class="input input-sm w-full pl-8 focus:outline-hidden focus:border-primary">
                      </div>
                    </div>
                    <div x-show="filter.column === 'tags'" class="border-b p-2 bg-base-50">
                      <div class="flex gap-2">
                        <button
                          type="button"
                          @click="selectAllTagOptions(index)"
                          :disabled="areAllTagsSelected(index)"
                          :class="areAllTagsSelected(index) ? 'btn-disabled' : ''"
                          class="btn btn-xs btn-outline flex-1">
                          Select All
                        </button>
                        <button
                          type="button"
                          @click="clearAllOptions(index)"
                          :disabled="filter.selectedValues.length === 0"
                          :class="filter.selectedValues.length === 0 ? 'btn-disabled' : ''"
                          class="btn btn-xs btn-outline flex-1">
                          Clear All
                        </button>
                      </div>
                    </div>
                    <div class="py-1">
                      <template x-for="option in filter.filteredOptions" :key="typeof option === 'object' ? option.id : option">
                        <label :for="`option-${index}-${typeof option === 'object' ? option.id : option}`" class="flex items-center px-4 py-2 hover:bg-base-200 cursor-pointer text-sm">
                          <input type="checkbox" :id="`option-${index}-${typeof option === 'object' ? option.id : option}`" :value="typeof option === 'object' ? option.id : option" x-model="filter.selectedValues" @change="triggerFilterChange()" class="checkbox checkbox-xs mr-2">
                          <span x-text="typeof option === 'object' ? option.label : option"></span>
                        </label>
                      </template>
                      <div x-show="filter.filteredOptions && filter.filteredOptions.length === 0" class="px-4 py-2 text-sm text-gray-500 italic">
                        No matching options
                      </div>
                    </div>
                  </div>
                </div>
              </template>

              <template x-if="filterData.columns[filter.column]?.type === 'string' && filter.operator !== 'any of'">
                <input type="text" x-model="filter.value" @input.debounce="triggerFilterChange()" class="w-40 block px-3 border border-base-200 rounded-lg bg-base-100 text-sm" style="height: 2rem;" placeholder="Enter value...">
              </template>

              <template x-if="filterData.columns[filter.column]?.type === 'timestamp'">
                <div>
                  <div
                    x-data="{ showDateRangeOptions: false }"
                    x-show="filter.operator === 'range'"
                    class="relative"
                  >
                    <div
                      @click="showDateRangeOptions = !showDateRangeOptions"
                      class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center"
                      style="height: 2rem;"
                    >
                      <span
                        x-text="dateRangeOptions.find(opt => opt.value === filter.value)?.label || 'Select Date Range'"
                      ></span>
                      <i class="fa-solid fa-caret-down fa-sm"></i>
                    </div>
                    <div
                      x-show="showDateRangeOptions"
                      @click.outside="showDateRangeOptions = false"
                      class="absolute z-50 mt-1 bg-base-100 rounded-lg max-h-64 overflow-y-auto w-40 border border-base-300"
                      style="z-index: 9999 !important;"
                    >
                      <div class="py-1">
                        <template x-for="option in dateRangeOptions" :key="option.value">
                          <div
                            @click="filter.value = option.value; triggerFilterChange(); syncDateRangeDropdown(filter.value); showDateRangeOptions = false;"
                            class="px-4 py-2 hover:bg-base-200 cursor-pointer text-sm"
                            :class="{ 'bg-base-200': filter.value === option.value }"
                          >
                            <span x-text="option.label"></span>
                          </div>
                        </template>
                      </div>
                    </div>
                  </div>
                    <!-- Date input for other operators -->
                  <input
                    x-show="filter.operator !== 'range'"
                    type="date"
                    x-model="filter.value"
                    @input="triggerFilterChange()"
                    class="w-40 block px-3 border border-base-200 rounded-lg bg-base-100 text-sm"
                    style="height: 2rem;"
                  >
                </div>
              </template>
            </div>
          </template>

          <!-- Remove Filter Button -->
          <button type="button" @click="removeFilter(index)" class="btn btn-square btn-sm btn-ghost" aria-label="Remove filter">Ã—</button>
        </div>
      </template>

      <!-- Add Filter Button -->
      <div class="flex justify-between items-center gap-2">
        <button type="button" @click="addFilter()" class="btn btn-sm btn-outline">+ Add Filter</button>
        <div class="flex gap-1">
          <button type="button" @click="saveFilterDialog.show()" class="btn btn-sm btn-outline">Save Filter</button>
          <button type="button" @click="savedFiltersDialog.show()" class="btn btn-sm btn-outline">My Saved Filters</button>
        </div>
      </div>
    </div>
    
    <!-- Starred Filters as Small Tabs -->
    <div class="mt-4">
      <div class="flex flex-wrap gap-2">
        <div x-show="starredFilters.length > 0" class="flex flex-col">
          <div class="flex items-center">
            <div class="flex p-2 text-gray-500 text-sm">
              Starred filters
            </div>
          </div>
          <div class="grid grid-cols-4 gap-1">
            <template x-for="filterSet in starredFilters" :key="filterSet.id">
              <div
                  class="inline-flex items-center gap-1 px-3 py-1 bg-base-200 rounded-full text-sm cursor-pointer hover:bg-base-300 transition-colors" 
                  :class="selectedSavedFilterId === filterSet.id ? 'bg-primary text-white hover:bg-primary' : ''"
                  @click="applyStarredFilter(filterSet.id, filterSet.name)">
                <span class="text-base-content" x-text="filterSet.name"></span>
              </div>
            </template>
          </div>
        </div>
        <div x-show="starredFilters.length === 0" class="flex justify-center items-center p-2 text-gray-500 text-sm">
          No starred filters
        </div>
      </div>
    </div>
  </div>
  {% include "filters/saved_filters_dialog.html" %}
  {% include "filters/save_filter_dialog.html" %}
</div>

{{ df_date_range_options|json_script:"date-range-options" }}
{{ df_filter_columns|json_script:"filter-columns-data" }}
<script>
  const filterColumns = JSON.parse(document.getElementById('filter-columns-data').textContent);
  const dateRangeOptions = JSON.parse(document.getElementById('date-range-options').textContent);
  document.addEventListener('alpine:init', () => {
    Alpine.data('filterComponent', () => ({
      dateRangeOptions,
      filterData: {
        showFilters: false,
        filters: [],
        loading: false,
        columns: filterColumns,
      },
      starredFilters: [],
      savedFilters: null,
      selectedSavedFilterId: null,
      experimentVersionsCache: {}, // Cache experiment ID -> version names

      init() {
        this.$watch('selectedSavedFilterId', (selectedSavedFilterId) => {
          if (selectedSavedFilterId) {
            const selectedSavedFilter = this.savedFilters.find(filter => filter.id === parseInt(selectedSavedFilterId));
            this.applySavedFilter(selectedSavedFilter);
          }
        })
        

        const App = SiteJS.app;
        this.loadFiltersFromQueryString(window.location.search);

        // Default filters set by user or team
        this.maybeApplyDefaultFilters();
        
        // Load starred filters on initialization
        this.loadStarredFilters();

          // Always trigger a data load on init to ensure correct data is shown
        this.$nextTick(() => {
          this.triggerFilterChange(false); // Don't update URL again since we just loaded from it
        });
        // for date range dropdown
        this.setLabelFromURL();
        window.addEventListener('popstate', () => {
          this.setLabelFromURL();
        });
        if (this.filterData.columns.participant || this.filterData.columns.remote_id) {
          fetch("{% if experiment.id %}{% url 'participants:participant_identifier' team.slug experiment.id %}{% else %}{% url 'participants:all_participant_identifiers' team.slug %}{% endif %}", {
            method: 'GET',
            credentials: 'same-origin',
            headers: {
              'X-CSRFToken': App.Cookies.get('csrftoken'),
              'Accept': 'application/json'
            }
          })
            .then(res => res.json())
            .then(data => {
              const identifiers = data.identifiers;
              const remoteIds = data.remote_ids;
              if (this.filterData.columns.participant) {
                this.filterData.columns.participant.options = identifiers;
              }
              if (this.filterData.columns.remote_id) {
                this.filterData.columns.remote_id.options = remoteIds;
              }

              this.filterData.filters.forEach(filter => {
                if (filter.column === 'participant') {
                  filter.filteredOptions = [...identifiers];
                } else if (filter.column === 'remote_id') {
                  filter.filteredOptions = [...remoteIds];
                }
              });
            })
            .catch(err => console.error("Failed to load participants", err));
        }
        Object.entries(this.filterData.columns).forEach(([key, column]) => {
          if (column.type === 'string' && !column.options) {
            column.operators = column.operators.filter(item => item !== 'any of');
          }
        })
      },

      toggleFilters() {
        this.filterData.showFilters = !this.filterData.showFilters;
        if (this.filterData.showFilters) {
          if (!this.starredFilters.length) {
            this.loadStarredFilters();
          }
          if (this.filterData.filters.length === 0) {
            this.addFilter();
          }
        }
      },

      addFilter() {
        this.filterData.filters.push({
          column: '',
          operator: '',
          value: '',
          selectedValues: [],
          availableOperators: [],
          showOptions: false,
          searchQuery: '',
          filteredOptions: []
        });
      },

      getActiveFilters(filters) {
        return filters.filter(filter => {
          return filter.column && filter.operator && (
            filter.value ||
            (Array.isArray(filter.selectedValues) && filter.selectedValues.length > 0)
          )
        })
      },

      updateOperatorsByColumn(index) {
        const filter = this.filterData.filters[index];
        const column = filter.column;
        if (column && this.filterData.columns[column]) {
          filter.availableOperators = this.filterData.columns[column].operators;
          filter.operator = filter.availableOperators[0] || '';
          filter.value = '';
          filter.selectedValues = [];
          filter.searchQuery = '';
          if (['choice', 'string', 'exclusive_choice'].includes(this.filterData.columns[column].type)) {
            filter.filteredOptions = [...this.filterData.columns[column].options || []];
          } else {
            filter.filteredOptions = [];
          }
        } else {
          filter.availableOperators = [];
          filter.operator = '';
          filter.filteredOptions = [];
        }
        this.triggerFilterChange();
      },

      removeFilter(index) {
        this.filterData.filters.splice(index, 1);
        if (this.filterData.filters.length === 0) {
          this.addFilter();
        }
        this.triggerFilterChange();
      },
      getActiveFilterCount() {
        return this.getActiveFilters(this.filterData.filters).length;
      },
      clearAllFilters() {
        this.filterData.filters = [];
        this.addFilter();
        this.filterData.showFilters = false;
        this.triggerFilterChange();
        this.selectedSavedFilterId = null;
      },

      isObjectChoiceFilter(filter) {
        const options = this.filterData.columns[filter.column].options;
        return options && options.length > 0 && typeof options[0] === 'object'
      },

      getSelectedDisplayText(filter) {
        if (this.isObjectChoiceFilter(filter)) {
          const displayValues = filter.selectedValues.map(id => {
            const option = this.filterData.columns[filter.column].options.find(exp => exp.id === parseInt(id));
            return option ? option.label : id;
          });
          const text = displayValues.join(', ');
          return text.length > 18 ? text.substring(0, 18) + '...' : text;
        } else {
          // For other filters, use values directly
          const text = filter.selectedValues.join(', ');
          return text.length > 18 ? text.substring(0, 18) + '...' : text;
        }
      },

      filterDropdownOptions(index) {
        const filter = this.filterData.filters[index];
        const column = filter.column;
        if (column && this.filterData.columns[column] && this.filterData.columns[column].options) {
          const searchQuery = (filter.searchQuery || '').toLowerCase().trim();

          if (!searchQuery) {
            filter.filteredOptions = [...this.filterData.columns[column].options];
          } else {
            filter.filteredOptions = this.filterData.columns[column].options.filter(option => {
              if (typeof option === 'object' && option.label) {
                return option.label.toLowerCase().includes(searchQuery);
              } else {
                // For simple string options
                return option.toLowerCase().includes(searchQuery);
              }
            });
          }
        }
      },
      loadFiltersFromQueryString(queryString) {
        const urlParams = new URLSearchParams(queryString);
        const filters = [];
        let maxIndex = -1;
        for (const [key, value] of urlParams.entries()) {
          const match = key.match(/filter_(\d+)_column/);
          if (match) {
            const index = parseInt(match[1]);
            if (index > maxIndex) maxIndex = index;
          }
        }
        for (let i = 0; i <= maxIndex; i++) {
          filters.push({
            column: '',
            operator: '',
            value: '',
            selectedValues: [],
            availableOperators: [],
            showOptions: false,
            searchQuery: '',
            filteredOptions: []
          });
        }
        for (let i = 0; i <= maxIndex; i++) {
          const columnParam = urlParams.get(`filter_${i}_column`);
          const operatorParam = urlParams.get(`filter_${i}_operator`);
          const valueParam = urlParams.get(`filter_${i}_value`);

          if (columnParam && operatorParam) {
            const filter = filters[i];
            filter.column = columnParam;

            if (this.filterData.columns[columnParam]) {
              filter.availableOperators = this.filterData.columns[columnParam].operators;
              filter.operator = operatorParam;
              if (operatorParam === 'range' && valueParam) {
                filter.options = this.filterData.columns[columnParam].options || this.dateRangeOptions;
                const matchedOption = filter.options.find(opt => opt.label === valueParam || opt.value === valueParam);
                if (matchedOption) {
                  filter.value = matchedOption.value.toString();
                } else {
                  filter.value = valueParam;
                }
              }
              else if (['any of', 'all of', 'excludes'].includes(operatorParam) && valueParam) {
                try {
                  const parsedValues = JSON.parse(valueParam);
                  if (this.isObjectChoiceFilter(filter)) {
                    filter.selectedValues = parsedValues.filter(id => {
                      return this.filterData.columns[filter.column].options.findIndex(exp => exp.id === parseInt(id)) >= 0;
                    });
                  } else {
                    filter.selectedValues = parsedValues;
                  }
                  if (this.filterData.columns[columnParam].options) {
                    filter.filteredOptions = [...this.filterData.columns[columnParam].options];
                  }
                } catch (e) {
                  console.error('Error parsing filter value from URL:', e);
                }
              } else if (valueParam) {
                filter.value = valueParam;
              }
            }
          }
        }
        this.filterData.filters = this.getActiveFilters(filters);
        this.filterData.showFilters = false;
        if (this.filterData.filters.length === 0) {
          this.addFilter();
        }
        
        // Fetch experiment versions for any experiment filters loaded from URL
        this.syncChatbotVersionsField(this.filterData.filters);
      },

      updateUrlWithFilters() {
        let activeFilters = this.getActiveFilters(this.filterData.filters);
        const params = new URLSearchParams(window.location.search);
        [...params.keys()].forEach(key => {
          if (key.startsWith('filter_')) {
            params.delete(key);
          }
        });
        activeFilters.forEach((filter, i) => {
          params.set(`filter_${i}_column`, filter.column);
          params.set(`filter_${i}_operator`, filter.operator);

          if (['any of', 'all of', 'excludes'].includes(filter.operator)) {
            if (filter.selectedValues && filter.selectedValues.length > 0) {
              let valuesToSerialize = filter.selectedValues;
              if (this.isObjectChoiceFilter(filter)) {
                valuesToSerialize = filter.selectedValues.map(label => {
                  const option = this.filterData.columns[filter.column].options.find(exp => exp.label === label);
                  return option ? option.id : label;
                });
              }
              params.set(`filter_${i}_value`, JSON.stringify(valuesToSerialize));
            }
          } else {
            params.set(`filter_${i}_value`, filter.value);
          }
        });

        const newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '') + window.location.hash;
        window.history.replaceState({}, '', newUrl);
      },

      triggerFilterChange(updateUrl = true) {
        this.filterData.loading = true;

        let filterParams = {};
        let activeFilters = this.getActiveFilters(this.filterData.filters);
        activeFilters.forEach((filter, i) => {
          filterParams[`filter_${i}_column`] = filter.column;
          filterParams[`filter_${i}_operator`] = filter.operator;

          if (['any of', 'all of', 'excludes'].includes(filter.operator)) {
            if (filter.selectedValues && filter.selectedValues.length > 0) {
              let valuesToSend = filter.selectedValues;
              if (this.isObjectChoiceFilter(filter)) {
                valuesToSend = filter.selectedValues.map(label => {
                  const option = this.filterData.columns[filter.column].options.find(exp => exp.label === label);
                  return option ? option.id : label;
                });
              }
              filterParams[`filter_${i}_value`] = JSON.stringify(valuesToSend);
            }
          } else {
            filterParams[`filter_${i}_value`] = filter.value;
          }
        });

        this.syncChatbotVersionsField(activeFilters);

        const dataSourceUrl = "{{df_filter_data_source_url}}";
        const dataSourceContainerId = "{{df_filter_data_source_container_id}}";
        if (updateUrl) {
          this.updateUrlWithFilters();
        }
        htmx.ajax('GET', dataSourceUrl, {
          target: "#" + dataSourceContainerId,
          swap: 'innerHTML',
          values: filterParams
        }).finally(() => {
          this.filterData.loading = false;
          // remove selected value from date range dropdown if range filter is removed
          const hasDateRangeRange = this.filterData.filters.some(f => f.column === '{{ df_date_range_column_name }}' && f.operator === 'range');
          if (!hasDateRangeRange) {
            this.syncDateRangeDropdown(null);
          }
        });
      },

      syncChatbotVersionsField(activeFilters) {
        // Update the versions column options based on selected experiments
        // This uses a cache to avoid refetching versions for experiments that's already loaded
        const experimentFilters = activeFilters.filter(f => f.column === 'experiment');
        if (experimentFilters.length === 0) {
          // Reset available versions to all
          this.filterData.filters.forEach(filter => {
            if (filter.column === 'versions') {
              filter.filteredOptions = this.filterData.columns.versions.options;
            }
          });
          return;
        }

        let allSelectedExperimentIds = new Set();
        experimentFilters.forEach(filter => {
          if (filter.selectedValues && filter.selectedValues.length > 0) {
            filter.selectedValues.forEach(id => allSelectedExperimentIds.add(id));
          }
        });

        // Find experiments that aren't cached yet
        const uncachedExperimentIds = [...allSelectedExperimentIds].filter(id => !this.experimentVersionsCache[id]);

        // Fetch versions for uncached experiments
        const fetchPromises = uncachedExperimentIds.map(experimentId => {
          const fetchUrl = "{% url 'experiments:get_experiment_version_names' team.slug '000' %}";
          return fetch(fetchUrl.replace('000', experimentId), {
            method: 'GET',
            credentials: 'same-origin',
            headers: {
              'X-CSRFToken': SiteJS.app.Cookies.get('csrftoken'),
              'Accept': 'application/json'
            }
          })
          .then(res => res.json())
          .then(data => {
            if (data.version_names) {
              this.experimentVersionsCache[experimentId] = data.version_names;
            }
            return data;
          })
          .catch(err => {
            console.error(`Failed to load versions for experiment ${experimentId}:`, err);
          });
        });

        Promise.all(fetchPromises).then(() => {
          let allVersions = new Set();
          allSelectedExperimentIds.forEach(experimentId => {
            const versions = this.experimentVersionsCache[experimentId] || [];
            versions.forEach(version => allVersions.add(version));
          });
          this.updateVersionsColumn(
            Array.from(allVersions).sort((a, b) => 
              parseInt(b.slice(1)) - parseInt(a.slice(1))
            )
          );
        });
      },

      updateVersionsColumn(versions) {
        // Update the versions column options if it exists
        if (!this.filterData.columns.versions) {
          return;
        }
        // Update available options in the versions column

        // Update available options for existing filters
        this.filterData.filters.forEach(filter => {
          if (filter.column === 'versions') {
            filter.filteredOptions = versions;
          }
        });

        // Update selected values to only include those still valid
        let activeFilters = this.getActiveFilters(this.filterData.filters);
        const activeVersionsFilter = activeFilters.find(f => f.column === 'versions');
        if (activeVersionsFilter) {
          let newSelectedValues = activeVersionsFilter.selectedValues.filter(val => versions.includes(val));
          activeVersionsFilter.selectedValues = newSelectedValues.sort();
        }
      },

      // Functions for date range dropdown
      setLabelFromURL() {
        const url = new URL(window.location.href);
        const params = url.searchParams;
        const matchedIndex = this.getDateRangeFilterIndex(params);
        if (matchedIndex !== null) {
          const filterValue = params.get(`filter_${matchedIndex}_value`);
          const found = this.dateRangeOptions.find(opt => opt.value === filterValue);
          this.selectedLabel = found?.label || '';
        } else {
          this.selectedLabel = '';
        }
      },

      selectOption(option) {
        this.selectedLabel = option.label;
        const column = this.filterData.columns['{{ df_date_range_column_name }}'];
        if (column) {
          this.filterData.filters = this.filterData.filters.filter(f => f.column !== column.query_param);
          this.filterData.filters.push({
            column: column.query_param,
            operator: 'range',
            value: option.value,
            availableOperators: column.operators,
          });
          this.filterData.filters = this.getActiveFilters(this.filterData.filters);
          this.triggerFilterChange();
        }
      },

      selectAllTagOptions(index) {
        const filter = this.filterData.filters[index];
        if (filter.column === 'tags') {
          const allTags = this.filterData.columns['tags'].options || [];
          filter.selectedValues = [...allTags];
          this.triggerFilterChange();
        }
      },

      clearAllOptions(index) {
        const filter = this.filterData.filters[index];
        filter.selectedValues = [];
        this.triggerFilterChange();
      },

      areAllTagsSelected(index) {
        const filter = this.filterData.filters[index];
        if (filter.column !== 'tags') return false;
        const allTags = this.filterData.columns['tags'].options || [];
        return allTags.length > 0 && filter.selectedValues.length === allTags.length;
      },

      getDateRangeFilterIndex(params) {
        for (const [key, val] of params.entries()) {
          if (key.includes('_column') && val === '{{ df_date_range_column_name }}') {
            const match = key.match(/filter_(\d+)_column/);
            if (match) {
              return match[1];
            }
          }
        }
        return null;
      },

      syncDateRangeDropdown(value) {
        const selected = this.dateRangeOptions.find(opt => opt.value === value);
        this.selectedLabel = selected ? selected.label : '';
      },

      async fetchSavedFilters() {
        if (this.savedFilters) return this.savedFilters;
        try {
          const url = '{% url "filters:list_filter_set" request.team.slug df_table_type %}';
          const res = await fetch(url, { credentials: 'same-origin' });
          const data = await res.json();
          this.savedFilters = data.results || [];
          return this.savedFilters;
        } catch (error) {
          console.error('Failed to load filter sets:', error);
          this.savedFilters = [];
          return [];
        }
      },

      async loadStarredFilters() {
        try {
          const savedFilters = await this.fetchSavedFilters();
          this.starredFilters = savedFilters.filter(fs => fs.is_starred);
        } catch (error) {
          console.error('Failed to load starred filters:', error);
          this.starredFilters = [];
        }
      },

      async maybeApplyDefaultFilters() {
        try {
          // Do nothing if there are already active filters
          if (this.getActiveFilters(this.filterData.filters).length > 0) return;

          const savedFilters = await this.fetchSavedFilters();
          const defaultFilter = savedFilters.find(fs => fs.is_default_for_user) || 
                                 savedFilters.find(fs => fs.is_default_for_team);
          
          if (defaultFilter?.filter_query_string) {
            this.filterData.filters = [];
            this.applySavedFilter(defaultFilter);
          }
        } catch (error) {
          console.error('Failed to load default filters:', error);
        }
      },

      async applyStarredFilter(filterSetId, filterSetName) {
        try {
          const savedFilters = await this.fetchSavedFilters();
          const starredFilter = savedFilters.find(fs => fs.id === filterSetId);
          if (!starredFilter) return;
          this.filterData.filters = [];
          this.applySavedFilter(starredFilter);
          this.selectedSavedFilterId = starredFilter.id;
        } catch (error) {
          console.error('Error applying starred filter:', error);
        }
      },
      async applySavedFilter(savedFilter) {
        this.loadFiltersFromQueryString(savedFilter.filter_query_string);
        this.triggerFilterChange();
      },

      async updateSavedFilterQueryString(id) {
        const filterSetName = this.getSavedFilterSetName(id);
        
        try {
          await this.makeSavedFilterUpdateRequest(id, { filter_query_string: window.location.search.substring(1) });
          await this.reloadSavedFilters(); 
          this.notifyUser(`"${filterSetName}" updated`, "success");
        } catch (error) {
          console.error('Error updating filter:', error);
          this.notifyUser('Failed to update filter', 'error');
        }
      },

      async toggleSavedFilterDefault(id, type) {
        const filterSetName = this.getSavedFilterSetName(id);
        const filterSet = this.savedFilters.find(f => f.id === id);
        
        if (!filterSet) return;
        
        const field = `is_default_for_${type}`;
        const isCurrentlyDefault = filterSet[field];
        const newValue = !isCurrentlyDefault;
        
        try {
          // Update UI immediately
          this.updateFilterProperty(id, field, newValue);
          
          // Make API call
          const payload = { [field]: newValue };
          await this.makeSavedFilterUpdateRequest(id, payload);
          
          if (newValue) {
            this.notifyUser(`"${filterSetName}" set as ${type} default`, "success");
          } else {
            this.notifyUser(`"${filterSetName}" removed as ${type} default`, "success");
          }
        } catch (error) {
          console.error('Error toggling default:', error);
          // Revert UI changes on error
          this.updateFilterProperty(id, field, isCurrentlyDefault);
          this.notifyUser('Failed to update default setting', 'error');
        }
      },

      async shareSavedFilter(id) {
        const filterSetName = this.getSavedFilterSetName(id);
        const filterSet = this.savedFilters.find(f => f.id === id);
        
        if (!filterSet) return;
        
        const isCurrentlyShared = filterSet.is_shared;
        const newValue = !isCurrentlyShared;
        
        try {
          // Update UI immediately
          this.updateFilterProperty(id, 'is_shared', newValue);
          
          // Make API call
          await this.makeSavedFilterUpdateRequest(id, { is_shared: newValue });
          
          if (newValue) {
            this.notifyUser(`"${filterSetName}" shared`, "success");
          } else {
            this.notifyUser(`"${filterSetName}" unshared`, "success");
          }
        } catch (error) {
          console.error('Error toggling share:', error);
          // Revert UI changes on error
          this.updateFilterProperty(id, 'is_shared', isCurrentlyShared);
          this.notifyUser('Failed to update share setting', 'error');
        }
      },

      async toggleSavedFilterStar(id) {
        const filterSetName = this.getSavedFilterSetName(id);
        const filterSet = this.savedFilters.find(f => f.id === id);
        
        if (!filterSet) return;
        
        const isCurrentlyStarred = filterSet.is_starred;
        const newValue = !isCurrentlyStarred;
        
        try {
          // Update UI immediately
          this.updateFilterProperty(id, 'is_starred', newValue);
          
          // Make API call
          await this.makeSavedFilterUpdateRequest(id, { is_starred: newValue });
          
          // Update starred filters list
          await this.loadStarredFilters();
          
          if (newValue) {
            this.notifyUser(`"${filterSetName}" starred`, "success");
          } else {
            this.notifyUser(`"${filterSetName}" unstarred`, "success");
          }
        } catch (error) {
          console.error('Error toggling star:', error);
          // Revert UI changes on error
          this.updateFilterProperty(id, 'is_starred', isCurrentlyStarred);
          await this.loadStarredFilters(); // Reload to revert starred filters list
          this.notifyUser('Failed to update star setting', 'error');
        }
      },

      async deleteSavedFilter(id, name) {
        if(!confirm(`Delete "${name}"?`)) return;
        
        try {
          await this.makeSavedFilterDeleteRequest(id);
          await this.reloadSavedFilters();
          this.notifyUser(`"${name}" deleted`, "success");
        } catch (error) {
          console.error('Error deleting filter:', error);
          this.notifyUser('Failed to delete filter', 'error');
        }
      },

      getSavedFilterSetName(id) {
        const filterSet = this.savedFilters.find(f => f.id === id);
        return filterSet?.name || 'Filter set';
      },

      async reloadSavedFilters() {
        this.savedFilters = null; // Clear cache to force refresh
        await this.fetchSavedFilters();
        await this.loadStarredFilters();
      },

      async makeSavedFilterUpdateRequest(filterId, updateBody) {
        await this.savedFilterRequest(filterId, "PATCH", updateBody);
      },

      async makeSavedFilterDeleteRequest(filterId) {
        await this.savedFilterRequest(filterId, "DELETE");
      },
      async savedFilterRequest(filterId, method, body) {
        const base = "{% url 'filters:filter_set' request.team.slug '000' %}";
        const url = base.replace("000", filterId);
        const opts = {method, credentials:"same-origin", headers: { "X-CSRFToken": SiteJS.app.Cookies.get("csrftoken")}
        };
        if (body) {
          opts.headers["Content-Type"]="application/json";
          opts.body=JSON.stringify(body);
        }
        const r = await fetch(url, opts);
        if(!r.ok) throw new Error("API failed");
        return r.json().catch(()=>({}));
      },

      notifyUser(msg, type="info") {
        alertify.notify(msg, type, 10);
      },

      // Helper method to update filter properties locally
      updateFilterProperty(filterId, property, value) {
        const filter = this.savedFilters.find(f => f.id === filterId);
        if (filter) {
          filter[property] = value;
          
          // Handle clearing other defaults when setting a new default
          if ((property === 'is_default_for_user' || property === 'is_default_for_team') && value) {
            this.savedFilters.forEach(f => {
              if (f.id !== filterId) {
                f[property] = false;
              }
            });
          }
        }
      },

      
    }));
    });
  </script>
