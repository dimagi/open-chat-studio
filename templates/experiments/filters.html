<div x-data="filterComponent" @click.outside="filterData.showFilters = false">
  <!-- Filter Button -->
  <div class="flex items-center">
    <button @click="toggleFilters()" class="btn btn-sm btn-outline">
      <i class="fa-solid fa-filter"></i> Filter
      <span x-show="getActiveFilterCount() > 0" x-cloak>(<span x-text="getActiveFilterCount()"></span>)</span>
    </button>

    <div x-show="filterData.loading" x-cloak class="ml-2">
      <i class="fa-solid fa-spinner fa-spin"></i>
    </div>

    <!-- Clear filters button -->
    <button
      x-show="getActiveFilterCount() > 0 && !filterData.loading"
      @click="clearAllFilters()"
      class="btn btn-square btn-sm btn-ghost"
      title="Clear all filters" x-cloak>
      x
    </button>
  </div>

  <!-- Filters Panel -->
  <div x-show="filterData.showFilters" class="absolute left-0 mt-2 p-4 bg-base-100 border border-base-200 rounded-lg shadow-lg z-10 w-fit" x-cloak>
    <div class="space-y-2">
      <template x-for="(filter, index) in filterData.filters" :key="index">
        <div class="flex items-center gap-2">
          <!-- Where/AND Label -->
          <div class="text-gray-500 font-medium w-16">
            <span x-text="index === 0 ? 'Where' : 'AND'"></span>
          </div>

          <!-- Column Selector -->
          <div class="relative">
            <div class="dropdown dropdown-bottom">
              <label tabindex="0" class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center" style="height: 2rem;">
                <span x-text="filter.column ? filterData.columns[filter.column].label : 'Select column'"></span>
                <i class="fa-solid fa-caret-down fa-sm"></i>
              </label>
              <ul tabindex="0" class="dropdown-content z-1 menu mt-1 p-2 bg-base-100 rounded-lg border border-base-200 w-40">
                <template x-for="(config, column) in filterData.columns" :key="column">
                  <li><a @click="filter.column = column; updateOperatorsByColumn(index)" x-text="config.label"></a></li>
                </template>
              </ul>
            </div>
          </div>

          <!-- Operator Selector -->
          <div x-show="filter.column" class="relative">
            <div class="dropdown dropdown-bottom">
              <label tabindex="0" class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center" style="height: 2rem;">
                <span x-text="filter.operator || 'Select operator'"></span>
                <i class="fa-solid fa-caret-down fa-sm"></i>
              </label>
              <ul tabindex="0" class="dropdown-content z-1 menu mt-1 p-2 bg-base-100 rounded-lg border border-base-200 w-40">
                <template x-for="operator in filter.availableOperators" :key="operator">
                  <li><a @click="filter.operator = operator; triggerFilterChange()" x-text="operator"></a></li>
                </template>
              </ul>
            </div>
          </div>

          <!-- Value Input (Choice, String, Timestamp) -->
          <template x-if="filter.operator">
            <div class="relative">
              <template x-if="filterData.columns[filter.column]?.type === 'choice' && ['any of', 'all of', 'excludes'].includes(filter.operator)">
                <div class="relative">
                  <div @click="filter.showOptions = !filter.showOptions" class="w-40 px-3 border border-base-200 rounded-lg bg-base-100 text-sm cursor-pointer flex justify-between items-center" style="height: 2rem;">
                    <span x-text="filter.selectedValues.length ? (filter.selectedValues.join(', ').length > 18 ? filter.selectedValues.join(', ').substring(0, 18) + '...' : filter.selectedValues.join(', ')) : 'Select'"></span>
                    <i class="fa-solid fa-caret-down fa-sm"></i>
                  </div>
                  <div x-show="filter.showOptions" @click.outside="filter.showOptions = false" class="absolute z-50 mt-1 bg-base-100 rounded-lg max-h-64 overflow-y-auto w-40 border border-base-300" style="z-index: 9999 !important;">
                    <div class="sticky top-0 bg-base-100 border-b p-2">
                      <div class="relative">
                        <input type="text" x-model="filter.searchQuery" @input="filterDropdownOptions(index)" placeholder="Search..." class="input input-sm w-full pl-8 focus:outline-hidden focus:border-primary">
                      </div>
                    </div>
                    <div class="py-1">
                      <template x-for="option in filter.filteredOptions" :key="option">
                        <label :for="`option-${index}-${option}`" class="flex items-center px-4 py-2 hover:bg-base-200 cursor-pointer text-sm">
                          <input type="checkbox" :id="`option-${index}-${option}`" :value="option" x-model="filter.selectedValues" @change="triggerFilterChange()" class="checkbox checkbox-xs mr-2">
                          <span x-text="option"></span>
                        </label>
                      </template>
                      <div x-show="filter.filteredOptions && filter.filteredOptions.length === 0" class="px-4 py-2 text-sm text-gray-500 italic">
                        No matching options
                      </div>
                    </div>
                  </div>
                </div>
              </template>

              <template x-if="filterData.columns[filter.column]?.type === 'string'">
                <input type="text" x-model="filter.value" @input.debounce="triggerFilterChange()" class="w-40 block px-3 border border-base-200 rounded-lg bg-base-100 text-sm" style="height: 2rem;" placeholder="Enter value...">
              </template>

              <template x-if="filterData.columns[filter.column]?.type === 'timestamp'">
                <input type="date" x-model="filter.value" @input="triggerFilterChange()" class="w-40 block px-3 border border-base-200 rounded-lg bg-base-100 text-sm" style="height: 2rem;">
              </template>
            </div>
          </template>

          <!-- Remove Filter Button -->
          <button @click="removeFilter(index)" class="btn btn-square btn-sm btn-ghost" aria-label="Remove filter">Ã—</button>
        </div>
      </template>

      <!-- Add Filter Button -->
      <button @click="addFilter()" class="btn btn-sm btn-outline">+ Add Filter</button>
    </div>
  </div>
</div>

{{ field_type_filters|json_script:"field-type-filters" }}
<script>
  const tags = JSON.parse(document.getElementById('available-tags-data').textContent);
  const versionsList = JSON.parse(document.getElementById('experiment-versions-data').textContent);
  const fieldTypeFilters = JSON.parse(document.getElementById('field-type-filters').textContent);
  const channelsList = JSON.parse(document.getElementById('channel-list-data').textContent);
  document.addEventListener('alpine:init', () => {
    Alpine.data('filterComponent', () => ({
      filterData: {
        showFilters: false,
        filters: [],
        loading: false,
        columns: {
          'participant': {type: 'string', operators: fieldTypeFilters.string, label: 'Participant'},
          'first_message': {type: 'timestamp', operators: fieldTypeFilters.timestamp, label: 'First Message'},
          'last_message': {type: 'timestamp', operators: fieldTypeFilters.timestamp, label: 'Last Message'},
          'tags': {type: 'choice', operators: fieldTypeFilters.choice, options: tags, label: 'Tags' },
          'versions': {type: 'choice', operators: fieldTypeFilters.choice.filter(op => op === 'any of' || op === 'excludes'), options: versionsList, label: 'Versions'},
          'channels': {type: 'choice', operators: fieldTypeFilters.choice, options: channelsList, label: 'Channels'}
        }
      },

      init() {
        this.loadFiltersFromUrl();
        let defaultFilterApplied = false;
        // set default filter to exclude API sessions
        if (this.filterData.filters.length === 1 && !this.filterData.filters[0].column) {
          this.filterData.filters = [{
            column: 'channels',
            operator: 'excludes',
            value: '',
            selectedValues: ['API'],
            availableOperators: ['any of', 'all of', 'excludes'],
            showOptions: false,
            searchQuery: '',
            filteredOptions: channelsList
          }];
          defaultFilterApplied = true;
        }
        const urlParams = new URLSearchParams(window.location.search);
        const showAllCheckbox = document.querySelector('input[name="show-all"]');
        if (urlParams.has('show-all') && showAllCheckbox) {
          showAllCheckbox.checked = true;
        }
        if (showAllCheckbox) {
          showAllCheckbox.addEventListener('change', () => {
            this.triggerFilterChange();
          });
        }
          // Always trigger a data load on init to ensure correct data is shown
        this.$nextTick(() => {
          this.triggerFilterChange(defaultFilterApplied); // Don't update URL again since we just loaded from it
        });
      },

      toggleFilters() {
        this.filterData.showFilters = !this.filterData.showFilters;
        if (this.filterData.showFilters && this.filterData.filters.length === 0) {
          this.addFilter();
        }
      },

      addFilter() {
        this.filterData.filters.push({
          column: '',
          operator: '',
          value: '',
          selectedValues: [],
          availableOperators: [],
          showOptions: false,
          searchQuery: '',
          filteredOptions: []
        });
      },

      updateOperatorsByColumn(index) {
        const filter = this.filterData.filters[index];
        const column = filter.column;
        if (column && this.filterData.columns[column]) {
          filter.availableOperators = this.filterData.columns[column].operators;
          filter.operator = filter.availableOperators[0] || '';
          filter.value = '';
          filter.selectedValues = [];
          filter.searchQuery = '';
          if (this.filterData.columns[column].type === 'choice') {
            filter.filteredOptions = [...this.filterData.columns[column].options || []];
          } else {
            filter.filteredOptions = [];
          }
        } else {
          filter.availableOperators = [];
          filter.operator = '';
          filter.filteredOptions = [];
        }
        this.triggerFilterChange();
      },

      removeFilter(index) {
        this.filterData.filters.splice(index, 1);
        if (this.filterData.filters.length === 0) {
          this.addFilter();
        }
        this.triggerFilterChange();
      },
      getActiveFilterCount() {
        return this.filterData.filters.filter(filter => {
          return filter.column && filter.operator && (
            filter.value ||
            (Array.isArray(filter.selectedValues) && filter.selectedValues.length > 0)
          );
        }).length;
      },
      clearAllFilters() {
        this.filterData.filters = [];
        this.addFilter();
        this.filterData.showFilters = false;
        this.triggerFilterChange();
      },
      filterDropdownOptions(index) {
        const filter = this.filterData.filters[index];
        const column = filter.column;
        if (column && this.filterData.columns[column] && this.filterData.columns[column].options) {
          const searchQuery = (filter.searchQuery || '').toLowerCase().trim();

          if (!searchQuery) {
            filter.filteredOptions = [...this.filterData.columns[column].options];
          } else {
            filter.filteredOptions = this.filterData.columns[column].options.filter(option =>
              option.toLowerCase().includes(searchQuery)
            );
          }
        }
      },
      loadFiltersFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const filters = [];
        let maxIndex = -1;
        for (const [key, value] of urlParams.entries()) {
          const match = key.match(/filter_(\d+)_column/);
          if (match) {
            const index = parseInt(match[1]);
            if (index > maxIndex) maxIndex = index;
          }
        }
        for (let i = 0; i <= maxIndex; i++) {
          filters.push({
            column: '',
            operator: '',
            value: '',
            selectedValues: [],
            availableOperators: [],
            showOptions: false,
            searchQuery: '',
            filteredOptions: []
          });
        }
        for (let i = 0; i <= maxIndex; i++) {
          const columnParam = urlParams.get(`filter_${i}_column`);
          const operatorParam = urlParams.get(`filter_${i}_operator`);
          const valueParam = urlParams.get(`filter_${i}_value`);

          if (columnParam && operatorParam) {
            const filter = filters[i];
            filter.column = columnParam;

            if (this.filterData.columns[columnParam]) {
              filter.availableOperators = this.filterData.columns[columnParam].operators;
              filter.operator = operatorParam;

              if (['any of', 'all of', 'excludes'].includes(operatorParam) && valueParam) {
                try {
                  filter.selectedValues = JSON.parse(valueParam);
                  if (this.filterData.columns[columnParam].options) {
                    filter.filteredOptions = [...this.filterData.columns[columnParam].options];
                  }
                } catch (e) {
                  console.error('Error parsing filter value from URL:', e);
                }
              } else if (valueParam) {
                filter.value = valueParam;
              }
            }
          }
        }
        this.filterData.filters = filters.filter(filter =>
          filter.column && filter.operator && (
            filter.value ||
            (Array.isArray(filter.selectedValues) && filter.selectedValues.length > 0)
          )
        );
        this.filterData.showFilters = false;
        if (this.filterData.filters.length === 0) {
          this.addFilter();
        }
      },

      updateUrlWithFilters() {
        const activeFilters = this.filterData.filters.filter(filter =>
          filter.column && filter.operator && (
            filter.value ||
            (Array.isArray(filter.selectedValues) && filter.selectedValues.length > 0)
          )
        );
        const params = new URLSearchParams(window.location.search);
        [...params.keys()].forEach(key => {
          if (key.startsWith('filter_')) {
            params.delete(key);
          }
        });
        activeFilters.forEach((filter, i) => {
          params.set(`filter_${i}_column`, filter.column);
          params.set(`filter_${i}_operator`, filter.operator);

          if (['any of', 'all of', 'excludes'].includes(filter.operator)) {
            if (filter.selectedValues && filter.selectedValues.length > 0) {
              params.set(`filter_${i}_value`, JSON.stringify(filter.selectedValues));
            }
          } else {
            params.set(`filter_${i}_value`, filter.value);
          }
        });

        const showAllCheckbox = document.querySelector('input[name="show-all"]');
        if (showAllCheckbox && showAllCheckbox.checked) {
          params.set('show-all', 'on');
        } else {
          params.delete('show-all');
        }

        const newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '') + window.location.hash;
        window.history.replaceState({}, '', newUrl);
      },

      triggerFilterChange(updateUrl = true) {
        this.filterData.loading = true;

        let filterParams = {};
        this.filterData.filters.forEach((filter, i) => {
          if (filter.column && filter.operator && (
            filter.value ||
            (Array.isArray(filter.selectedValues) && filter.selectedValues.length > 0)
          )) {
            filterParams[`filter_${i}_column`] = filter.column;
            filterParams[`filter_${i}_operator`] = filter.operator;

            if (['any of', 'all of', 'excludes'].includes(filter.operator)) {
              if (filter.selectedValues && filter.selectedValues.length > 0) {
                filterParams[`filter_${i}_value`] = JSON.stringify(filter.selectedValues);
              }
            } else {
              filterParams[`filter_${i}_value`] = filter.value;
            }
          }
        });
        const sessionsTableUrl = document.getElementById('sessions-table').getAttribute('hx-get');
        const showAllCheckbox = document.querySelector('input[name="show-all"]');
        if (showAllCheckbox && showAllCheckbox.checked) {
          filterParams['show-all'] = 'on';
        }
        if (updateUrl) {
          this.updateUrlWithFilters();
        }
        htmx.ajax('GET', sessionsTableUrl, {
          target: '#sessions-table',
          swap: 'innerHTML',
          values: filterParams
        }).finally(() => {
          this.filterData.loading = false;
        });
      }
    }));
  });
</script>
